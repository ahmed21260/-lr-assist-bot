const TelegramBot = require('node-telegram-bot-api');
const fs = require('fs');
const path = require('path');
const https = require('https');
const moment = require('moment');

// Import modules
const config = require('./config');
const { initializeFirebase, FirestoreService, StorageService } = require('./firebase');
const GeoportailService = require('./geoportail');
const Utils = require('./utils');

// Initialize services
const bot = new TelegramBot(config.telegram.token, { polling: true });
const firestore = new FirestoreService();
const storage = new StorageService();
const geoportal = new GeoportailService();

// Initialize Firebase
initializeFirebase();

// Ensure directories exist
const PHOTO_DIR = path.join(__dirname, 'data', 'photos');
if (!fs.existsSync(PHOTO_DIR)) {
  fs.mkdirSync(PHOTO_DIR, { recursive: true });
}

// Menu principal
const mainMenu = {
  reply_markup: {
    keyboard: [
      ['üì∏ Envoyer une photo', 'üìç Partager ma position'],
      ['‚úÖ Checklist s√©curit√©', '‚ö†Ô∏è D√©clencher une urgence'],
      ['üìò Fiches techniques', '‚ÑπÔ∏è Aide'],
      ['üìä Historique', 'üîß Param√®tres']
    ],
    resize_keyboard: true
  }
};

// /start command
bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  const userName = msg.from.first_name || 'utilisateur';
  const userId = msg.from.id.toString();
  
  const welcome = `üëã Bonjour *${userName}*, bienvenue sur *LR ASSIST* !\n\n` +
    `üö¶ Application de terrain pour op√©rateurs ferroviaires\n` +
    `üì± Votre ID: \`${userId}\`\n\n` +
    `Utilise le menu ci-dessous pour acc√©der aux fonctions.`;

  try {
    // Save user info to Firestore
    await firestore.saveMessage({
      userId,
      userName,
      message: 'Utilisateur connect√©',
      type: 'connection',
      status: 'normal',
      chatId
    });

    bot.sendMessage(chatId, welcome, { 
      parse_mode: 'Markdown', 
      ...mainMenu 
    });
  } catch (error) {
    console.error('‚ùå Erreur sauvegarde connexion:', error);
    bot.sendMessage(chatId, welcome, { 
      parse_mode: 'Markdown', 
      ...mainMenu 
    });
  }
});

// Debug logging
bot.on('message', (msg) => {
  const user = msg.from.username || msg.from.first_name || msg.from.id;
  const messageType = msg.photo ? 'PHOTO' : msg.location ? 'LOCATION' : 'TEXT';
  console.log(`üì© ${user} (${msg.chat.id}) => ${messageType}: ${msg.text || '[non-text message]'}`);
});

// Handle text messages
bot.on('message', async (msg) => {
  const chatId = msg.chat.id;
  const text = msg.text;
  const userId = msg.from.id.toString();
  const userName = msg.from.first_name || 'Utilisateur';
  
  if (!text || text.startsWith('/')) return;

  try {
    switch (text) {
      case 'üì∏ Envoyer une photo':
        bot.sendMessage(chatId, 'üì∏ Envoie ta photo directement ici. Elle sera sauvegard√©e avec m√©tadonn√©es et upload√©e dans le cloud.');
        break;

      case 'üìç Partager ma position':
        bot.sendMessage(chatId, 'üìç Clique pour envoyer ta position GPS. Le PK SNCF sera calcul√© automatiquement üëá', {
          reply_markup: {
            keyboard: [[{ text: "üì° Envoyer ma position", request_location: true }]],
            resize_keyboard: true,
            one_time_keyboard: true
          }
        });
        break;

      case '‚úÖ Checklist s√©curit√©':
        await sendChecklist(chatId);
        break;

      case '‚ö†Ô∏è D√©clencher une urgence':
        await handleEmergency(chatId, userName, userId);
        break;

      case 'üìò Fiches techniques':
        await sendTechnicalSheets(chatId);
        break;

      case 'üìä Historique':
        await sendHistory(chatId, userId);
        break;

      case 'üîß Param√®tres':
        await sendSettings(chatId);
        break;

      case '‚ÑπÔ∏è Aide':
        await sendHelp(chatId);
        break;

      default:
        // Save regular message to Firestore
        await firestore.saveMessage({
          userId,
          userName,
          message: text,
          type: 'message',
          status: 'normal',
          chatId
        });

        bot.sendMessage(chatId, "‚úÖ Message enregistr√©. Utilise le menu pour les actions sp√©cifiques üëá", mainMenu);
    }
  } catch (error) {
    console.error('‚ùå Erreur traitement message:', error);
    bot.sendMessage(chatId, "‚ùå Erreur lors du traitement. R√©essayez.", mainMenu);
  }
});

// Handle photos
bot.on('photo', async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id.toString();
  const userName = msg.from.first_name || 'Utilisateur';
  const caption = msg.caption || 'Photo sans description';
  
  try {
    console.log('üì∏ Traitement photo re√ßue...');
    
    // Get the highest quality photo
    const fileId = msg.photo[msg.photo.length - 1].file_id;
    const file = await bot.getFile(fileId);
    const filePath = file.file_path;
    
    // Download photo
    const url = `https://api.telegram.org/file/bot${config.telegram.token}/${filePath}`;
    const timestamp = Date.now();
    const originalFilename = `photo_${timestamp}.jpg`;
    const originalPath = path.join(PHOTO_DIR, originalFilename);
    
    // Download file
    await downloadFile(url, originalPath);
    
    // Extract EXIF data
    const exifData = await Utils.extractExifData(originalPath);
    
    // Compress image
    const compressedFilename = `compressed_${originalFilename}`;
    const compressedPath = path.join(PHOTO_DIR, compressedFilename);
    const compressionResult = await Utils.compressImage(originalPath, compressedPath, {
      width: 1920,
      height: 1080,
      quality: 80
    });
    
    // Generate thumbnail
    const thumbnailFilename = `thumb_${originalFilename}`;
    const thumbnailPath = path.join(PHOTO_DIR, thumbnailFilename);
    await Utils.generateThumbnail(originalPath, thumbnailPath, 300);
    
    // Upload to Firebase Storage
    const storagePath = `${moment().format('YYYY/MM/DD')}/${userId}_${timestamp}.jpg`;
    const uploadResult = await storage.uploadPhoto(compressedPath, storagePath, {
      userId,
      userName,
      timestamp: timestamp.toString(),
      originalSize: fs.statSync(originalPath).size,
      compressedSize: compressionResult.size,
      exifData: exifData ? JSON.stringify(exifData) : null
    });
    
    // Save to Firestore
    const photoData = {
      userId,
      userName,
      filename: originalFilename,
      url: uploadResult.url,
      storagePath: uploadResult.path,
      caption,
      timestamp,
      exifData,
      originalSize: fs.statSync(originalPath).size,
      compressedSize: compressionResult.size,
      chatId
    };
    
    await firestore.savePhoto(photoData);
    
    // Save message with photo reference
    await firestore.saveMessage({
      userId,
      userName,
      message: `üì∏ ${caption}`,
      type: 'photo',
      status: 'normal',
      photoUrl: uploadResult.url,
      chatId
    });
    
    // Send confirmation
    const confirmationMsg = `üì∏ *Photo trait√©e avec succ√®s*\n\n` +
      `üìù Description: ${caption}\n` +
      `üìè Taille originale: ${Utils.formatFileSize(fs.statSync(originalPath).size)}\n` +
      `üìè Taille compress√©e: ${Utils.formatFileSize(compressionResult.size)}\n` +
      `üîó [Voir photo](${uploadResult.url})\n\n` +
      (exifData && exifData.gpsLatitude ? 
        `üìç GPS: ${exifData.gpsLatitude.toFixed(6)}, ${exifData.gpsLongitude.toFixed(6)}` : 
        `‚ö†Ô∏è Pas de donn√©es GPS dans la photo`);
    
    bot.sendMessage(chatId, confirmationMsg, { 
      parse_mode: 'Markdown',
      ...mainMenu 
    });
    
    // Clean up local files
    fs.unlinkSync(originalPath);
    fs.unlinkSync(compressedPath);
    fs.unlinkSync(thumbnailPath);
    
  } catch (error) {
    console.error('‚ùå Erreur traitement photo:', error);
    bot.sendMessage(chatId, "‚ùå Erreur lors du traitement de la photo. R√©essayez.", mainMenu);
  }
});

// Handle location with precise railway geometry
bot.on('location', async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id.toString();
  const userName = msg.from.first_name || 'Utilisateur';
  const { latitude, longitude } = msg.location;
  
  try {
    console.log('üìç Traitement localisation re√ßue avec g√©om√©trie pr√©cise...');
    
    // Validate GPS coordinates
    if (!Utils.validateGPS(latitude, longitude)) {
      bot.sendMessage(chatId, "‚ùå Coordonn√©es GPS invalides.", mainMenu);
      return;
    }
    
    // Calculate PK SNCF with precise geometry
    const pkResult = await geoportal.calculatePKSNCF(latitude, longitude);
    
    // Get detailed railway line info
    const railwayInfo = await geoportal.getRailwayLineInfo(latitude, longitude);
    
    // Get nearby infrastructure
    const infrastructure = await geoportal.getNearbyInfrastructure(latitude, longitude, 2000);
    
    // Save to Firestore
    const locationData = {
      userId,
      userName,
      latitude,
      longitude,
      pkSNCF: pkResult.pk,
      lineId: pkResult.lineId,
      lineName: pkResult.lineName,
      confidence: pkResult.confidence,
      distance: pkResult.distance,
      method: pkResult.method,
      railwayInfo,
      infrastructure,
      timestamp: Date.now(),
      chatId
    };
    
    await firestore.saveLocation(locationData);
    
    // Save message with location
    await firestore.saveMessage({
      userId,
      userName,
      message: `üìç Position partag√©e - ${pkResult.pk} (${pkResult.lineName})`,
      type: 'location',
      status: 'normal',
      location: { 
        latitude, 
        longitude, 
        pkSNCF: pkResult.pk,
        lineName: pkResult.lineName,
        confidence: pkResult.confidence
      },
      chatId
    });
    
    // Send confirmation with detailed information
    const geoUrl = `https://www.geoportail.gouv.fr/carte?c=${longitude},${latitude}&z=19&l=TRANSPORTNETWORKS.RAILWAYS`;
    
    let confirmationMsg = `üìç *Position re√ßue et trait√©e*\n\n` +
      `üìä Coordonn√©es:\n` +
      `‚Ä¢ Latitude: ${latitude.toFixed(6)}\n` +
      `‚Ä¢ Longitude: ${longitude.toFixed(6)}\n\n` +
      `üö¶ Point Kilom√©trique SNCF:\n` +
      `‚Ä¢ PK: *${pkResult.pk}*\n` +
      `‚Ä¢ Ligne: ${pkResult.lineName}\n` +
      `‚Ä¢ Direction: ${railwayInfo.direction}\n` +
      `‚Ä¢ Confiance: ${pkResult.confidence}\n` +
      `‚Ä¢ Distance: ${pkResult.distance ? `${Math.round(pkResult.distance)}m` : 'N/A'}\n` +
      `‚Ä¢ M√©thode: ${pkResult.method}\n\n`;
    
    // Add infrastructure information if available
    if (infrastructure.stations.length > 0 || infrastructure.signals.length > 0) {
      confirmationMsg += `üèóÔ∏è Infrastructure proche:\n`;
      if (infrastructure.stations.length > 0) {
        confirmationMsg += `‚Ä¢ Gares: ${infrastructure.stations.length}\n`;
      }
      if (infrastructure.signals.length > 0) {
        confirmationMsg += `‚Ä¢ Signaux: ${infrastructure.signals.length}\n`;
      }
      confirmationMsg += `\n`;
    }
    
    confirmationMsg += `üîó [Voir sur Geoportail (Voies SNCF)](${geoUrl})`;
    
    bot.sendMessage(chatId, confirmationMsg, { 
      parse_mode: 'Markdown',
      ...mainMenu 
    });
    
  } catch (error) {
    console.error('‚ùå Erreur traitement localisation:', error);
    bot.sendMessage(chatId, "‚ùå Erreur lors du traitement de la position. R√©essayez.", mainMenu);
  }
});

// Send checklist
async function sendChecklist(chatId) {
  const keyboard = [
    [{ text: "‚ùå V√©rifier position train", callback_data: 'check1' }],
    [{ text: "‚ùå Contacter chef chantier", callback_data: 'check2' }],
    [{ text: "‚ùå Activer signalisations", callback_data: 'check3' }],
    [{ text: "‚ùå Bloquer circulation voie", callback_data: 'check4' }],
    [{ text: "‚ùå Confirmer mise hors voie", callback_data: 'check5' }]
  ];
  
  bot.sendMessage(chatId, "‚úÖ *Checklist de s√©curit√© ferroviaire* :", {
    parse_mode: 'Markdown',
    reply_markup: { inline_keyboard: keyboard }
  });
}

// Handle callback queries (checklist)
bot.on('callback_query', async (query) => {
  const chatId = query.message.chat.id;
  const userId = query.from.id.toString();
  const userName = query.from.first_name || 'Utilisateur';
  const data = query.data;
  
  try {
    if (data.startsWith('check')) {
      // Handle checklist items
      const steps = [
        { code: 'check1', label: "V√©rifier position train" },
        { code: 'check2', label: "Contacter chef chantier" },
        { code: 'check3', label: "Activer signalisations" },
        { code: 'check4', label: "Bloquer circulation voie" },
        { code: 'check5', label: "Confirmer mise hors voie" }
      ];
      
      const step = steps.find(s => s.code === data);
      if (step) {
        // Save checklist action to Firestore
        await firestore.saveMessage({
          userId,
          userName,
          message: `‚úÖ Checklist: ${step.label}`,
          type: 'checklist',
          status: 'normal',
          chatId
        });
        
        bot.answerCallbackQuery(query.id, { text: `‚úÖ ${step.label} valid√©` });
      }
    }
  } catch (error) {
    console.error('‚ùå Erreur callback query:', error);
    bot.answerCallbackQuery(query.id, { text: "‚ùå Erreur" });
  }
});

// Handle emergency
async function handleEmergency(chatId, userName, userId) {
  try {
    // Get last known location
    const locations = await firestore.getLocations({ userId, limit: 1 });
    const lastLocation = locations[0];
    
    const alertMsg = `üö® *ALERTE D'URGENCE FERROVIAIRE*\n\n` +
      `üë§ Op√©rateur: ${userName}\n` +
      `üÜî ID: ${userId}\n` +
      `‚è∞ Heure: ${moment().format('DD/MM/YYYY HH:mm:ss')}\n\n` +
      (lastLocation ? 
        `üìç Derni√®re position connue:\n` +
        `‚Ä¢ PK: ${lastLocation.pkSNCF}\n` +
        `‚Ä¢ Coordonn√©es: ${lastLocation.latitude}, ${lastLocation.longitude}\n` +
        `‚Ä¢ [Voir sur carte](https://www.geoportail.gouv.fr/carte?c=${lastLocation.longitude},${lastLocation.latitude}&z=19&l=TRANSPORTNETWORKS.RAILWAYS)` :
        `‚ùå Position non disponible. Demander position imm√©diatement.`);
    
    // Save emergency message
    await firestore.saveMessage({
      userId,
      userName,
      message: 'üö® ALERTE D\'URGENCE D√âCLENCH√âE',
      type: 'emergency',
      status: 'urgent',
      location: lastLocation ? { 
        latitude: lastLocation.latitude, 
        longitude: lastLocation.longitude, 
        pkSNCF: lastLocation.pkSNCF 
      } : null,
      chatId
    });
    
    // Send to admin
    bot.sendMessage(config.telegram.adminChatId, alertMsg, { 
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[
          { text: "üìû Contacter op√©rateur", callback_data: `contact_${userId}` }
        ]]
      }
    });
    
    // Confirm to user
    bot.sendMessage(chatId, "üö® *Alerte d'urgence envoy√©e aux administrateurs*\n\nVotre position a √©t√© transmise. Restez en s√©curit√©.", {
      parse_mode: 'Markdown',
      ...mainMenu
    });
    
  } catch (error) {
    console.error('‚ùå Erreur alerte urgence:', error);
    bot.sendMessage(chatId, "‚ùå Erreur lors de l'envoi de l'alerte. Contactez directement les secours.", mainMenu);
  }
}

// Send technical sheets
async function sendTechnicalSheets(chatId) {
  const sheets = [
    {
      title: "üìò Fiche Machine CAT M323F",
      content: "Engin : CAT M323F Rail-Route\n‚úÖ Emprise ferroviaire valid√©e\nüîß √âquipements : rototilt, benne preneuse, remorque\nüîí S√©curisation : signalisation, v√©rif OCP\nüìç Position √† envoyer avant intervention."
    },
    {
      title: "üö¶ Proc√©dures de s√©curit√©",
      content: "1. V√©rifier position train\n2. Contacter chef chantier\n3. Activer signalisations\n4. Bloquer circulation voie\n5. Confirmer mise hors voie"
    },
    {
      title: "üìû Contacts d'urgence",
      content: "üö® Urgence : 112\nüö¶ SNCF : 3635\nüë∑ Chef chantier : [Num√©ro local]\nüîß Maintenance : [Num√©ro local]"
    }
  ];
  
  for (const sheet of sheets) {
    bot.sendMessage(chatId, `*${sheet.title}*\n\n${sheet.content}`, {
      parse_mode: 'Markdown'
    });
  }
  
  bot.sendMessage(chatId, "üìò Utilisez le menu pour d'autres actions üëá", mainMenu);
}

// Send history
async function sendHistory(chatId, userId) {
  try {
    const messages = await firestore.getMessages({ userId, limit: 10 });
    
    if (messages.length === 0) {
      bot.sendMessage(chatId, "üìä Aucun historique disponible.", mainMenu);
      return;
    }
    
    let historyMsg = "üìä *Votre historique r√©cent:*\n\n";
    
    messages.forEach((msg, index) => {
      const timestamp = Utils.formatTimestamp(msg.createdAt, 'DD/MM HH:mm');
      const typeIcon = msg.type === 'photo' ? 'üì∏' : msg.type === 'location' ? 'üìç' : 'üí¨';
      historyMsg += `${index + 1}. ${typeIcon} ${msg.message || 'Sans message'} (${timestamp})\n`;
    });
    
    bot.sendMessage(chatId, historyMsg, { 
      parse_mode: 'Markdown',
      ...mainMenu 
    });
    
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration historique:', error);
    bot.sendMessage(chatId, "‚ùå Erreur lors de la r√©cup√©ration de l'historique.", mainMenu);
  }
}

// Send settings
async function sendSettings(chatId) {
  const settingsMsg = "üîß *Param√®tres LR ASSIST*\n\n" +
    "üì± Notifications : Activ√©es\n" +
    "üìç GPS : Activ√©\n" +
    "üì∏ Upload photos : Activ√©\n" +
    "üö¶ PK SNCF : Calcul automatique\n\n" +
    "Pour modifier les param√®tres, contactez l'administrateur.";
  
  bot.sendMessage(chatId, settingsMsg, { 
    parse_mode: 'Markdown',
    ...mainMenu 
  });
}

// Send help
async function sendHelp(chatId) {
  const helpMsg = `‚ÑπÔ∏è *Aide LR ASSIST*\n\n` +
    `üö¶ Application de terrain pour op√©rateurs ferroviaires\n\n` +
    `üì∏ *Photo* : Signalement probl√®me avec m√©tadonn√©es\n` +
    `üìç *Position* : Envoi GPS avec calcul PK SNCF automatique\n` +
    `‚úÖ *Checklist* : √âtapes s√©curit√© avant intervention\n` +
    `‚ö†Ô∏è *Urgence* : D√©clenche alerte imm√©diate\n` +
    `üìò *Fiches techniques* : Documents machines ferroviaires\n` +
    `üìä *Historique* : Consultation actions r√©centes\n\n` +
    `üë®‚Äçüîß Compatible : CAT M323F, OCP, signalisation, zone d'emprise ferroviaire\n\n` +
    `üîó Support : Contactez l'administrateur`;
  
  bot.sendMessage(chatId, helpMsg, { 
    parse_mode: 'Markdown',
    ...mainMenu 
  });
}

// Download file utility
function downloadFile(url, dest) {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(dest);
    https.get(url, (response) => {
      response.pipe(file);
      file.on('finish', () => {
        file.close();
        resolve();
      });
    }).on('error', (err) => {
      fs.unlink(dest, () => {}); // Delete the file async
      reject(err);
    });
  });
}

// Error handling
bot.on('error', (error) => {
  console.error('‚ùå Erreur bot Telegram:', error);
});

bot.on('polling_error', (error) => {
  console.error('‚ùå Erreur polling Telegram:', error);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\nüõë Arr√™t du bot LR ASSIST...');
  bot.stopPolling();
  process.exit(0);
});

console.log("üö¶ BOT LR ASSIST d√©marr√© avec Firebase et Geoportail");
console.log("üì± En √©coute des messages...");
console.log("üîß Console CLI disponible avec: npm run console");
